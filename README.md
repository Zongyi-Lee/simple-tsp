### 项目概要

这个项目实现了一个简单的RPC框架，目前是作为一个个人项目练手，后面有时间可能会在此基础上进一步优化代码并实现新的feature。

目前的实现只做了基础的RPC调用，服务器使用Epoll来进行IO复用支持更多的请求，同时使用了线程池来执行实际的请求的任务计算并发送返回报文。这些设计使得服务端具有了一定的并发可用性，但是如果想要达到支持工业级并发可能还需要对代码进行改进。

### 使用

+ 服务器端：

  服务器需要注册服务函数，具体来说需要实现继承自RPCMethod的类并实现其execute函数，其函数原型为：

  ```c++
  void
  RPCMethod::execute(std::vector<simprpc::XmlElement>& params, std::vector<simprpc::XmlElement>& ret>) = 0;
  ```

  第一个为函数的参数列表，第二个用来存储远程调用返回果。其中`XmlElement`是用来封装各种参数类型的一个通用类，可接受基础数据类型以及`string`类型直接构造。

  向服务器注册好函数后启动侦听服务，就可以开始接受客户请求。

+ 客户端：客户端十分简单，根据服务器端端ip和端口号就可以创建client对象，client构造函数会尝试与服务器建立TCP连接。连接成功建立后用户可以并发调用client实例的execute方法，其接口为

  ```c++
  bool execute(std::string& funName, const std::vector<Xmlelement>& params, std::vector<XmlElement>& ret);
  ```

  当成功接收到服务器返回的成功执行报文，会将结果装入ret中，返回true，否则执行失败返回false。

### 项目架构：

1. 底层序列化以及反序列化：

   本项目采用XML方式来进行参数的序列化和反序列化，这种方式优点是比较直观，代码实现比较容易，目前可以支持基础数据类型以及简单vector和struct对象的传输。缺点是报文的序列化和反序列化操作比较耗时，报文采用字符串明文传输安全性和效率会打折扣。

2. 服务端结构和客户端：

   + 服务器端主要依赖如下几个类：

     + RPCConnection：这个类用来表征客户到服务器之间的一个连接，本项目的RPC是基于TCP协议的，每个RPCConnection实例都对应着一个TCP连接的socket，Server接受到连接请求会生成一个RPCCoonnection，由RPCConnection类来存储和管理来自对应client的请求和结果
     + RPCMethod：这是一个抽象类，定义了一个execute的通用接口函数，真实注册的RPC服务函数都需要继承这个类并实现execute函数
     + RPCServer：RPC服务的提供者，接受RPCMethod注册，底册采用一个Map来记录MethodName到RPCMethod类的映射关系(这个设计确实并不是很令人满意)。服务器启动后进行一些简单的初始化，使用epoll来管理连接请求和到达的报文，目前的实现是所有报文接受全部由一个线程来完成，每次接受到一个完整报文就会向线程池中提交一个任务。之后线程池的空余线程会取到任务，实际执行请求并生成返回报文发送。
     + ConnectionManager：这个类用来统一管理RPCConnection。在接到报文时，每次都需要根据socket的文件描述符来寻找并修改对应RPCConnection的状态，项目采用了map这个结构来加速查找。但是map本身的操作并不是线程安全的，因此需要加锁来保证原子性，这在连接比较多的情况下很容易造成性能损耗。因此采用哈希分桶的设计来减少锁争用的发生。

   + Client端：

     对应RPCClient类，内部包含一个请求队列和一个结果队列，前者对应还未发送的请求，后者对应在等待的服务器结果。每当线程发起execute调用，线程从将自己的请求生成对应的xml报文，挂入请求队列，然后生成一个回复的结构体，设置完成状态为false挂入结果队列表明在等待一个结果。之后：

     + 如果没有其他线程负责IO请求，则当前线程负责发送和接受报文
     + 如果有其他线程在负责请求，则会进入睡眠，让出CPU。

#### 

到目前来说这个项目还是处于一个draft版的完成阶段，还有许多有价值的特性没有添加，经过了一些基础的检测，我采用20个线程发送请求进行了测试，可以正常处理，但是可能仍然存在一些未注意到的bug需要更加严格的测试。此外还有一些功能的实现不完善，需要进一步改进